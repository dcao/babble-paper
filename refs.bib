
@article{knoth_liquid_2020,
	title = {Liquid resource types},
	volume = {4},
	issn = {2475-1421, 2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3408988},
	doi = {10.1145/3408988},
	language = {en},
	number = {ICFP},
	urldate = {2020-11-20},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Knoth, Tristan and Wang, Di and Reynolds, Adam and Hoffmann, Jan and Polikarpova, Nadia},
	month = aug,
	year = {2020},
	pages = {1--29},
	file = {Full Text:/home/david/Zotero/storage/4CGJM9FA/Knoth et al. - 2020 - Liquid resource types.pdf:application/pdf}
}

@inproceedings{knoth_resource-guided_2019,
	address = {Phoenix, AZ, USA},
	title = {Resource-guided program synthesis},
	isbn = {978-1-4503-6712-7},
	url = {http://dl.acm.org/citation.cfm?doid=3314221.3314602},
	doi = {10.1145/3314221.3314602},
	language = {en},
	urldate = {2020-11-20},
	booktitle = {Proceedings of the 40th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}  - {PLDI} 2019},
	publisher = {ACM Press},
	author = {Knoth, Tristan and Wang, Di and Polikarpova, Nadia and Hoffmann, Jan},
	year = {2019},
	pages = {253--268}
}

@incollection{hutchison_resource_2012,
	address = {Berlin, Heidelberg},
	title = {Resource {Aware} {ML}},
	volume = {7358},
	isbn = {978-3-642-31423-0 978-3-642-31424-7},
	url = {http://link.springer.com/10.1007/978-3-642-31424-7_64},
	urldate = {2020-11-20},
	booktitle = {Computer {Aided} {Verification}},
	publisher = {Springer Berlin Heidelberg},
	author = {Hoffmann, Jan and Aehlig, Klaus and Hofmann, Martin},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Madhusudan, P. and Seshia, Sanjit A.},
	year = {2012},
	doi = {10.1007/978-3-642-31424-7_64},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {781--786},
	file = {Full Text:/home/david/Zotero/storage/KVA3B7D5/Hoffmann et al. - 2012 - Resource Aware ML.pdf:application/pdf}
}

@inproceedings{polikarpova_program_2016,
	address = {Santa Barbara, CA, USA},
	title = {Program synthesis from polymorphic refinement types},
	isbn = {978-1-4503-4261-2},
	url = {http://dl.acm.org/citation.cfm?doid=2908080.2908093},
	doi = {10.1145/2908080.2908093},
	language = {en},
	urldate = {2020-11-20},
	booktitle = {Proceedings of the 37th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation} - {PLDI} 2016},
	publisher = {ACM Press},
	author = {Polikarpova, Nadia and Kuraj, Ivan and Solar-Lezama, Armando},
	year = {2016},
	pages = {522--538},
	file = {Full Text:/home/david/Zotero/storage/ABDFYQB3/Polikarpova et al. - 2016 - Program synthesis from polymorphic refinement type.pdf:application/pdf}
}

@incollection{hutchison_abstract_2013,
	address = {Berlin, Heidelberg},
	title = {Abstract {Refinement} {Types}},
	volume = {7792},
	isbn = {978-3-642-37035-9 978-3-642-37036-6},
	url = {http://link.springer.com/10.1007/978-3-642-37036-6_13},
	urldate = {2020-11-21},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Vazou, Niki and Rondon, Patrick M. and Jhala, Ranjit},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Felleisen, Matthias and Gardner, Philippa},
	year = {2013},
	doi = {10.1007/978-3-642-37036-6_13},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {209--228},
	file = {Full Text:/home/david/Zotero/storage/VM9CYTME/Vazou et al. - 2013 - Abstract Refinement Types.pdf:application/pdf}
}

@article{burghardt_implementing_2014,
	title = {Implementing {Anti}-{Unification} {Modulo} {Equational} {Theory}},
	url = {http://arxiv.org/abs/1404.0953},
	abstract = {We present an implementation of E-anti-unification as defined in Heinz (1995), where tree-grammar descriptions of equivalence classes of terms are used to compute generalizations modulo equational theories. We discuss several improvements, including an efficient implementation of variable-restricted E-anti-unification from Heinz (1995), and give some runtime figures about them. We present applications in various areas, including lemma generation in equational inductive proofs, intelligence tests, diverging Knuth-Bendix completion, strengthening of induction hypotheses, and theory formation about finite algebras.},
	language = {en},
	urldate = {2021-01-26},
	journal = {arXiv:1404.0953 [cs]},
	author = {Burghardt, Jochen and Heinz, Birgit},
	month = apr,
	year = {2014},
	note = {arXiv: 1404.0953},
	keywords = {68T15, Computer Science - Artificial Intelligence, Computer Science - Logic in Computer Science, F.4.2, I.2.6},
	annote = {Comment: 113 pages; 57 figures},
	file = {1404.0953.pdf:/home/david/default/papers/1404.0953.pdf:application/pdf}
}

@article{ellis_dreamcoder_nodate,
	title = {{DreamCoder}: {Building} interpretable hierarchical knowledge representations with wake-sleep {Bayesian} program learning},
	language = {en},
	author = {Ellis, Kevin and Wong, Catherine and Nye, Maxwell and Sable-Meyer, Mathias and Cary, Luc and Morales, Lucas and Hewitt, Luke and Solar-Lezama, Armando and Tenenbaum, Joshua B},
	pages = {68},
	year = {2014},
	file = {dreamcoder_with_supplement.pdf:/home/david/default/papers/dreamcoder_with_supplement.pdf:application/pdf}
}

@article{singh_blinkfill_2016,
	title = {{BlinkFill}: semi-supervised programming by example for syntactic string transformations},
	volume = {9},
	issn = {2150-8097},
	shorttitle = {{BlinkFill}},
	url = {https://dl.acm.org/doi/10.14778/2977797.2977807},
	doi = {10.14778/2977797.2977807},
	abstract = {The recent Programming By Example (PBE) techniques such as FlashFill have shown great promise for enabling end-users to perform data transformation tasks using inputoutput examples. Since examples are inherently an underspeciﬁcation, there are typically a large number of hypotheses conforming to the examples, and the PBE techniques suﬀer from scalability issues for ﬁnding the intended program amongst the large space.},
	language = {en},
	number = {10},
	urldate = {2021-01-27},
	journal = {Proceedings of the VLDB Endowment},
	author = {Singh, Rishabh},
	month = jun,
	year = {2016},
	pages = {816--827},
	file = {p816-singh.pdf:/home/david/default/papers/p816-singh.pdf:application/pdf}
}

@article{willsey_egg_2021,
	title = {egg: {Fast} and extensible equality saturation},
	volume = {5},
	issn = {2475-1421, 2475-1421},
	shorttitle = {egg},
	url = {https://dl.acm.org/doi/10.1145/3434304},
	doi = {10.1145/3434304},
	abstract = {An e-graph efficiently represents a congruence relation over many expressions. Although they were originally developed in the late 1970s for use in automated theorem provers, a more recent technique known as equality saturation repurposes e-graphs to implement state-of-the-art, rewrite-driven compiler optimizations and program synthesizers. However, e-graphs remain unspecialized for this newer use case. Equality saturation workloads exhibit distinct characteristics and often require ad-hoc e-graph extensions to incorporate transformations beyond purely syntactic rewrites.
            This work contributes two techniques that make e-graphs fast and extensible, specializing them to equality saturation. A new amortized invariant restoration technique called rebuilding takes advantage of equality saturation's distinct workload, providing asymptotic speedups over current techniques in practice. A general mechanism called e-class analyses integrates domain-specific analyses into the e-graph, reducing the need for ad hoc manipulation.
            We implemented these techniques in a new open-source library called egg. Our case studies on three previously published applications of equality saturation highlight how egg's performance and flexibility enable state-of-the-art results across diverse domains.},
	language = {en},
	number = {POPL},
	urldate = {2021-01-29},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Willsey, Max and Nandi, Chandrakana and Wang, Yisu Remy and Flatt, Oliver and Tatlock, Zachary and Panchekha, Pavel},
	month = jan,
	year = {2021},
	pages = {1--29},
	file = {3434304.pdf:/home/david/default/papers/3434304.pdf:application/pdf}
}

@article{gulwani_synthesis_nodate,
	title = {Synthesis of {Loop}-free {Programs}},
	abstract = {We consider the problem of synthesizing loop-free programs that implement a desired functionality using components from a given library. Speciﬁcations of the desired functionality and the library components are provided as logical relations between their respective input and output variables. The library components can be used at most once, and hence the library is required to contain a reasonable overapproximation of the multiset of the components required. We solve the above component-based synthesis problem using a constraint-based approach that involves ﬁrst generating a synthesis constraint, and then solving the constraint. The synthesis constraint is a ﬁrst-order ∃∀ logic formula whose size is quadratic in the number of components. We present a novel algorithm for solving such constraints. Our algorithm is based on counterexample guided iterative synthesis paradigm and uses off-the-shelf SMT solvers.},
	language = {en},
	author = {Gulwani, Sumit and Jha, Susmit and Tiwari, Ashish and Venkatesan, Ramarathnam},
	pages = {12},
	file = {pldi2011-bitvector.pdf:/home/david/default/papers/pldi2011-bitvector.pdf:application/pdf}
}


@article{solar-lezama_program_2013,
	title = {Program sketching},
	volume = {15},
	issn = {1433-2779, 1433-2787},
	url = {http://link.springer.com/10.1007/s10009-012-0249-7},
	doi = {10.1007/s10009-012-0249-7},
	abstract = {Sketching is a synthesis methodology that aims to bridge the gap between a programmer’s high-level insights about a problem and the computer’s ability to manage low-level details. In sketching, the programmer uses a partial program, a sketch, to describe the desired implementation strategy, and leaves the low-level details of the implementation to an automated synthesis procedure. In order to generate an implementation from the programmer provided sketch, the synthesizer uses counterexample-guided inductive synthesis (CEGIS). Inductive synthesis refers to the process of generating candidate implementations from concrete examples of correct or incorrect behavior. CEGIS combines a SATbased inductive synthesizer with an automated validation procedure, a bounded model-checker, that checks whether the candidate implementation produced by inductive synthesis is indeed correct and to produce new counterexamples. The result is a synthesis procedure that is able to handle complex problems from a variety of domains including ciphers, scientiﬁc programs, and even concurrent data-structures.},
	language = {en},
	number = {5-6},
	urldate = {2021-02-11},
	journal = {International Journal on Software Tools for Technology Transfer},
	author = {Solar-Lezama, Armando},
	month = oct,
	year = {2013},
	pages = {475--495},
	file = {Solar-Lezama - 2013 - Program sketching.pdf:/Users/david/Zotero/storage/8SIMHYSX/Solar-Lezama - 2013 - Program sketching.pdf:application/pdf},
}

@article{wang_learning_2021,
	title = {Learning {Part}-{Based} {Abstractions} for {Visual} {Object} {Concepts}},
	abstract = {The ability to represent semantic structure in the environment — objects, parts, and relations — is a core aspect of human visual perception and cognition. Here we leverage recent advances in program synthesis to develop an algorithm for learning the part-based structure of drawings as represented by graphics programs. Our algorithm iteratively learns a library of abstract subroutines that can be used to more compactly represent a set of drawings by capturing their common structure. Our experi- ments revealed that under the constraint of cost of learning, the algorithm can exploit the statistical regularities in the environ- ment and learn a compact representation of the data distribution, and we further showed how these internal and external factors impacted the resulting library. Together, these findings con- tribute to our understanding of how humans might represent perceptual concepts and acquire abstractions.},
	language = {en},
	journal = {Under submission},
	author = {Wang, Haoliang and Polikarpova, Nadia and Fan, Judith},
	year = {2021},
	file = {smiley.pdf:/Users/david/Dropbox/papers/smiley.pdf:application/pdf},
}
